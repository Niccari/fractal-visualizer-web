(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))n(s);new MutationObserver(s=>{for(const r of s)if(r.type==="childList")for(const o of r.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&n(o)}).observe(document,{childList:!0,subtree:!0});function t(s){const r={};return s.integrity&&(r.integrity=s.integrity),s.referrerPolicy&&(r.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?r.credentials="include":s.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function n(s){if(s.ep)return;s.ep=!0;const r=t(s);fetch(s.href,r)}})();const ne=[{kind:"koch_triangle_outer",complexity:4,center:{x:.2,y:.3},scale:{w:1,h:1},rotation:{angle:30,speed:1},mutation:{size:1,angle:1},randomizer:{size:{amplify:10,seed:-90129041},angle:{amplify:-2.4,seed:1124901342}},style:{type:"line",thickness:3},color:{type:"cool",alpha:.9,speed:1}},{kind:"koch_triangle_inner",complexity:5,center:{x:.5,y:1.2},scale:{w:.4,h:.4},rotation:{angle:30,speed:-.9},mutation:{size:-1,angle:1},randomizer:{size:{amplify:0,seed:90129041},angle:{amplify:0,seed:124818419}},style:{type:"line",thickness:10},color:{type:"warm",alpha:.9,speed:.5}},{kind:"binary_tree",complexity:8,center:{x:.5,y:1.9},scale:{w:.2,h:.2},rotation:{angle:10,speed:-.2},mutation:{size:1.1,angle:.88},randomizer:{size:{amplify:.5,seed:90129041},angle:{amplify:-.1,seed:124818419}},style:{type:"triangle",thickness:10},color:{type:"rainbow",alpha:.9,speed:.5}},{kind:"tri_cis",complexity:6,center:{x:.8,y:3.3},scale:{w:1,h:1},rotation:{angle:80,speed:0},mutation:{size:1.2,angle:1.7},randomizer:{size:{amplify:0,seed:90129041},angle:{amplify:0,seed:124818419}},style:{type:"line",thickness:3},color:{type:"heat",alpha:.9,speed:.5}},{kind:"starmine",complexity:10,center:{x:.2,y:4.2},scale:{w:3,h:3},rotation:{angle:20,speed:.5},style:{type:"triangle",thickness:3},color:{type:"warm",alpha:.9,speed:.5}},{kind:"starmine",complexity:8,center:{x:.4,y:4.3},scale:{w:2.5,h:2.5},rotation:{angle:20,speed:.5},style:{type:"triangle",thickness:3},color:{type:"forest",alpha:.9,speed:.5}},{kind:"starmine",complexity:8,center:{x:.6,y:4.4},scale:{w:2,h:2},rotation:{angle:20,speed:.5},style:{type:"triangle",thickness:3},color:{type:"cool",alpha:.9,speed:.5}},{kind:"starmine",complexity:6,center:{x:.8,y:4.5},scale:{w:1.5,h:1.5},rotation:{angle:20,speed:.5},style:{type:"triangle",thickness:3},color:{type:"monochrome",alpha:.9,speed:.5}},{kind:"sunrise",complexity:100,center:{x:.4,y:5.1},scale:{w:3,h:3},rotation:{angle:-20,speed:0},style:{type:"curve",thickness:4},color:{type:"heat",alpha:.9,speed:.5}},{kind:"fold_ccurve",complexity:9,center:{x:.4,y:6},scale:{w:.4,h:.4},rotation:{angle:30,speed:0},mutation:{size:1,angle:1.5},randomizer:{size:{amplify:3,seed:90129041},angle:{amplify:-.6,seed:124818419}},style:{type:"line",thickness:5},color:{type:"pastel",alpha:.6,speed:.5}},{kind:"random",complexity:100,center:{x:.7,y:8},scale:{w:30,h:30},rotation:{angle:30,speed:0},mutation:{size:1,angle:1.5},randomizer:{size:{amplify:.1,seed:90129041},angle:{amplify:.1,seed:124818419}},style:{type:"circles",thickness:1.2},color:{type:"cool",alpha:.1,speed:10}},{kind:"random",complexity:100,center:{x:.7,y:9.5},scale:{w:30,h:30},rotation:{angle:30,speed:0},mutation:{size:1,angle:1.5},randomizer:{size:{amplify:.1,seed:90129041},angle:{amplify:.1,seed:124818419}},style:{type:"circles",thickness:1.2},color:{type:"warm",alpha:.1,speed:10}},{kind:"fold_dragon",complexity:10,center:{x:.5,y:11.2},scale:{w:.7,h:1.2},rotation:{angle:90,speed:.02},mutation:{size:.6,angle:-3.4},randomizer:{size:{amplify:.5,seed:-90129041},angle:{amplify:.1,seed:124818419}},style:{type:"curve",thickness:5},color:{type:"rainbow",alpha:.4,speed:2}}],se={charts:ne},C=g=>g*Math.PI/180,A={LINE:"line",TRIANGLE:"triangle",CIRCLES:"circles",CURVE:"curve"},c={CIRCLE:"start",STAR:"star",CLOVER:"clover",SUNRISE:"sunrise",RANDOM:"random",STARMINE:"starmine",KOCH_CURVE:"koch_curve",KOCH_TRIANGLE_INNER:"koch_triangle_inner",KOCH_TRIANGLE_OUTER:"koch_triangle_outer",FOLD_DRAGON:"fold_dragon",FOLD_CCURVE:"fold_ccurve",TRI_CIS:"tri_cis",TRI_TRANS:"tri_trans",BINARY_TREE:"binary_tree"},O={RAINBOW:"rainbow",WARM:"warm",FOREST:"forest",COOL:"cool",HEAT:"heat",MONOCHROME:"monochrome",PASTEL:"pastel"};class T{config;colorTable=[];alphaHex;colors=[];prevStart=null;gradientRainbows=[{position:0,red:255,green:0,blue:0},{position:43,red:255,green:255,blue:0},{position:85,red:0,green:255,blue:0},{position:128,red:0,green:255,blue:255},{position:171,red:0,green:0,blue:255},{position:223,red:255,green:0,blue:255},{position:255,red:255,green:0,blue:0}];gradientWarm=[{position:0,red:255,green:0,blue:0},{position:128,red:255,green:255,blue:0},{position:255,red:255,green:0,blue:0}];gradientForest=[{position:0,red:255,green:255,blue:0},{position:128,red:0,green:255,blue:0},{position:255,red:255,green:255,blue:0}];gradientCool=[{position:0,red:0,green:0,blue:255},{position:128,red:0,green:255,blue:255},{position:255,red:0,green:0,blue:255}];gradientHeat=[{position:0,red:255,green:255,blue:0},{position:43,red:255,green:0,blue:0},{position:85,red:0,green:0,blue:255},{position:128,red:0,green:0,blue:0},{position:171,red:0,green:0,blue:255},{position:223,red:255,green:0,blue:0},{position:255,red:255,green:255,blue:0}];gradientMonochrome=[{position:0,red:0,green:0,blue:0},{position:128,red:255,green:255,blue:255},{position:255,red:0,green:0,blue:0}];gradientPastel=[{position:0,red:255,green:154,blue:154},{position:85,red:255,green:255,blue:154},{position:170,red:154,green:255,blue:255},{position:255,red:255,green:154,blue:154}];static colorToHex=e=>{const t=Math.round(e).toString(16);return t.length===1?`0${t}`:t};constructor(e){this.config=e,this.alphaHex=T.colorToHex(Math.floor(255*this.config.alpha));const t=(()=>{switch(e.type.toString()){case O.RAINBOW:return this.gradientRainbows;case O.WARM:return this.gradientWarm;case O.FOREST:return this.gradientForest;case O.COOL:return this.gradientCool;case O.HEAT:return this.gradientHeat;case O.MONOCHROME:return this.gradientMonochrome;case O.PASTEL:return this.gradientPastel;default:throw Error("Not Implemented")}})();let n=1,s=t[0],r=t[1];for(let o=0;o<256;o+=1){const i=(o-s.position)/(r.position-s.position),a=s.red+i*(r.red-s.red),u=s.green+i*(r.green-s.green),l=s.blue+i*(r.blue-s.blue);this.colorTable.push(`#${T.colorToHex(a)}${T.colorToHex(u)}${T.colorToHex(l)}${this.alphaHex}`),r.position===o&&(s=r,n+=1,r=t[n])}}get(e,t){let n;if(this.colors.length!==t||this.prevStart===null)this.colors=[],n=t;else{n=Math.abs(e-this.prevStart);for(let s=0;s<n;s++)this.colors.shift()}for(let s=0;s<n;s++){const r=(e+this.config.speed*s)%256;this.colors.push(this.colorTable[r])}return this.prevStart=e,this.colors}}const I=(g,e,t)=>{const n=Math.sin(t),s=Math.cos(t);return{x:g.x+e.x*s-e.y*n,y:g.y+e.x*n+e.y*s}};class re{shaper;config;identity;constructor(e,t){this.shaper=e,this.config=t}reset(){const{shaper:e,config:t}=this,n=e.configureBasePoints(t);this.identity={basePoints:n,orders:e.configureOrders(t.complexity),config:t,colorGenerator:new T(t.color),timestamp:0,points:new Array(n.length)}}simulate(){const{identity:e}=this;if(!e)throw new Error("shape not reset");const{config:t,orders:n,timestamp:s,points:r}=e,{rotation:o,scale:i,center:a}=t;e.config.kind===c.RANDOM&&this.reset();const u=o.angle+o.speed*s,l=e.colorGenerator.get(s,e.basePoints.length);for(let d=0;d<e.basePoints.length;d++){const y=e.basePoints[d],f={x:y.x*i.w,y:y.y*i.h};r[d]=I(a,f,u)}return e.timestamp+=1,{points:r,style:t.style,colors:l,orders:n}}}class L{x=123456789;y=362436069;z=521288629;seed;constructor(e){this.seed=e}generate=()=>{const e=this.x^this.x<<11;return this.x=this.y,this.y=this.z,this.z=this.seed,this.seed=this.seed^this.seed>>>19^(e^e>>>8),this.seed/2**32}}const V={baseAmplitude:.1};class M{static pointCounts(e){return 2**(Math.max(Math.min(e,10),2)+1)}configureBasePoints(e){const t=new L(e.randomizer?.size?.seed||-1),n=new L(e.randomizer?.angle?.seed||-1),s=[{x:0,y:-.1,index:0},{x:0,y:0,index:1}],r=this.divideBasePoints(e,s[0],s[1],1,.85,C(45),t,n);return[s[0],s[1],...r]}divideBasePoints(e,t,n,s,r,o,i,a){const{complexity:u,randomizer:l,mutation:d}=e,y=(l?.size?.amplify||0)*i.generate(),f=(l?.angle?.amplify||0)*a.generate(),h=r*(y+(d?.size||1)),w=o*(f+(d?.angle||1));if(s>=Math.floor(M.pointCounts(u)/2))return[];const U={x:h*(n.x-t.x),y:h*(n.y-t.y)},X=2*s,p=2*s+1,R={...I(n,U,w),index:X},b={...I(n,U,-w),index:p},P=[];return P.push(...this.divideBasePoints(e,n,R,X,h,w,i,a)),P.push(...this.divideBasePoints(e,n,b,p,h,w,i,a)),[R,b,...P.sort((G,W)=>G.index-W.index)]}configureOrders(e){const t=M.pointCounts(e)/2;return[{link:[0,1]},...this.setOrdersRecursive(t,1).sort((n,s)=>n.link[1]-s.link[1])]}setOrdersRecursive(e,t){if(t>=e)return[];const n=2*t,s=2*t+1,r={link:[t,n]},o={link:[t,s]},i=this.setOrdersRecursive(e,n),a=this.setOrdersRecursive(e,s);return[r,o,...i,...a]}}const v=g=>Array.from({length:g},(e,t)=>t),m={LOOP:"loop",START_END_2X_FASTER:"start_end_2x_faster",END_2X_FASTER:"end_2x_faster",LINEAR:"linear"};class x{generate(e){const{type:t,pointCount:n}=e;switch(t){case m.LINEAR:return v(n-1).map(s=>({link:[s,(s+1)%n]}));case m.LOOP:return v(n).map(s=>({link:[s,(s+1)%n]}));case m.START_END_2X_FASTER:return v(n).map(s=>({link:[2*s%n,2*(s+1)%n]}));case m.END_2X_FASTER:return v(n).map(s=>({link:[s,2*(s+1)%n]}));default:return[]}}}const S={CIRCLE:"circle",RANDOM:"random"};class H{generate(e){const{type:t,length:n}=e,{baseAmplitude:s}=V;switch(t){case S.CIRCLE:return v(n).map(o=>2*Math.PI*o/n).map(o=>({x:s*Math.sin(o),y:s*Math.cos(o)}));case S.RANDOM:return v(n).map(()=>({x:s*(Math.random()-.5),y:s*(Math.random()-.5)}));default:return[]}}}class N{static pointCounts(e){return e}configureBasePoints(e){const t=N.pointCounts(e.complexity);return new H().generate({type:S.CIRCLE,length:t})}configureOrders(e){const t=N.pointCounts(e);return new x().generate({type:m.LOOP,pointCount:t})}}class k{static pointCounts(e){return e*40}configureBasePoints(e){const t=k.pointCounts(e.complexity),{baseAmplitude:n}=V;return v(t).map(s=>{const r=2*Math.PI*s/t,o=n*Math.sin(e.complexity*r);return{x:o*Math.cos(r-Math.PI),y:o*Math.sin(r-Math.PI)}})}configureOrders(e){const t=k.pointCounts(e);return new x().generate({type:m.LOOP,pointCount:t})}}class K{recursive(e,t,n,s,r,o,i,a){const{randomizer:u,mutation:l,complexity:d}=e,y=o[t%o.length],f={x:r.x-s.x,y:r.y-s.y},h=[];if(y.folds.forEach((p,R)=>{const b=R===0||p.fromStart?s:p.fromEnd?r:h[R-1],P=p.fromEnd?-1:1,{length:G,radian:W}=p,J=(u?.size?.amplify??0)*i.generate(),Z=(u?.angle?.amplify??0)*a.generate(),Q=P*G*(J+(l?.size??1)),ee=W*(Z+(l?.angle??1)),te={x:f.x*Q,y:f.y*Q};h.push(I(b,te,ee))}),n===d)return t===0?[s,...h,r]:t<y.folds.length-1?[...h,r]:[...h,r];const w=[s,...h,r];return[...Array.from({length:w.length-1},(p,R)=>R).map(p=>[w[p],w[p+1]]).map((p,R)=>{const b=(y.folds.length+1)*t+R;return[...this.recursive(e,b,n+1,p[0],p[1],o,i,a)]}).reduce((p,R)=>p.concat(R))]}createPoints(e,t){const n=new L(e.randomizer?.size?.seed||-1),s=new L(e.randomizer?.angle?.seed||-1),r={x:-.1,y:0},o={x:.1,y:0};return this.recursive(e,0,2,r,o,t,n,s)}}class q{engine;constructor(){this.engine=new K}static selectFoldRules(e){const t={length:Math.SQRT1_2,radian:C(45)},n={length:Math.SQRT1_2,radian:C(-45)};switch(e){case c.FOLD_CCURVE:return[{folds:[n]}];case c.FOLD_DRAGON:return[{folds:[t]},{folds:[n]}];default:throw new Error("Unsupported curve type!")}}configureBasePoints(e){const t=q.selectFoldRules(e.kind);return this.engine.createPoints(e,t)}configureOrders(e){const t=2**(e-1)+1;return new x().generate({type:m.LINEAR,pointCount:t})}}class z{static pointCounts(e){return e}configureBasePoints(e){const t=z.pointCounts(e.complexity);return new H().generate({type:S.RANDOM,length:t})}configureOrders(e){const t=z.pointCounts(e);return new x().generate({type:m.LOOP,pointCount:t})}}class _{static pointCounts(e){return e}configureBasePoints(e){const t=_.pointCounts(e.complexity);return new H().generate({type:S.CIRCLE,length:t})}configureOrders(e){const t=_.pointCounts(e);return new x().generate({type:m.START_END_2X_FASTER,pointCount:t})}}class F{static pointCounts(e){return e*2}configureBasePoints(e){const t=F.pointCounts(e.complexity),{baseAmplitude:n}=V;return v(t).map(s=>{const r=2*Math.PI*s/t-Math.PI,o=s%2===0?n:n/4;return{x:o*Math.cos(r),y:o*Math.sin(r)}})}configureOrders(e){return new x().generate({type:m.LOOP,pointCount:F.pointCounts(e)})}}class D{static pointCounts(e){return e}configureBasePoints(e){return new H().generate({type:S.CIRCLE,length:D.pointCounts(e.complexity)})}configureOrders(e){return new x().generate({type:m.END_2X_FASTER,pointCount:D.pointCounts(e)})}}class B{engine;constructor(){this.engine=new K}static getFoldRule(){return[{folds:[{length:1/3,radian:0},{length:1/3,radian:C(60)},{length:1/3,radian:C(-60)}]}]}configureBasePoints(e){const t=B.getFoldRule();return this.engine.createPoints(e,t)}configureOrders(e){const t=2**(2*(e-1))+1;return new x().generate({type:m.LINEAR,pointCount:t})}}class ${engine;constructor(){this.engine=new K}static selectFoldRules(e){const t=[{folds:[{length:.5,radian:C(90)},{length:.5,radian:0,fromStart:!0},{length:.5,radian:C(90),fromEnd:!0}]}],n=[{folds:[{length:1/2,radian:C(90)},{length:1/2,radian:0,fromStart:!0},{length:1/2,radian:C(-90),fromEnd:!0}]}];return e===c.TRI_CIS?n:t}configureBasePoints(e){const t=$.selectFoldRules(e.kind);return this.engine.createPoints(e,t)}configureOrders(e){const t=2**(2*(e-1))+1;return new x().generate({type:m.LINEAR,pointCount:t})}}class oe{kochCurve;constructor(){this.kochCurve=new B}configureBasePoints(e){const t=e.kind===c.KOCH_TRIANGLE_INNER;let n=this.kochCurve.configureBasePoints(e);const s=C(120);t&&(n=n.map(i=>({...i,y:-i.y}))),n=n.map(i=>({...i,y:i.y+.1/Math.sqrt(3)}));const r=n.map(i=>I({x:0,y:0},i,s)),o=r.map(i=>I({x:0,y:0},i,s));return[...n,...o,...r]}configureOrders(e){const t=3*(2**(2*(e-1))+1);return new x().generate({type:m.LINEAR,pointCount:t})}}class j{static instantiateChart=e=>{switch(e){case c.STAR:return new _;case c.STARMINE:return new F;case c.SUNRISE:return new D;case c.CIRCLE:return new N;case c.CLOVER:return new k;case c.RANDOM:return new z;case c.FOLD_CCURVE:case c.FOLD_DRAGON:return new q;case c.KOCH_CURVE:return new B;case c.KOCH_TRIANGLE_INNER:case c.KOCH_TRIANGLE_OUTER:return new oe;case c.TRI_CIS:case c.TRI_TRANS:return new $;case c.BINARY_TREE:return new M;default:throw new Error("Unsupported chart type!")}};load=()=>{const t=se.charts.map(n=>{const s={...n,kind:n.kind,style:{...n.style,type:n.style.type},color:{...n.color,type:n.color.type},rotation:{angle:C(n.rotation.angle),speed:C(n.rotation.speed)},complexity:n.complexity};return{chart:j.instantiateChart(s.kind),config:s}}).map(n=>new re(n.chart,n.config));return t.map(n=>n.reset()),t}}class ie{visualizer;simulators;scrollEndCount;touchScrollPrevY;scrollY;animationId;lastFrameTime=0;targetFrameRate=60;isVisible=!0;isPaused=!1;constructor(e){this.visualizer=e,this.simulators=new j().load(),this.scrollEndCount=0,this.scrollY=(()=>{const t=new URL(document.location.href).searchParams;return Number.parseInt(t.get("depth")||"0",10)})(),document.addEventListener("visibilitychange",this.handleVisibilityChange)}start=(e=60)=>{this.targetFrameRate=e,this.animate()};animate=(e=performance.now())=>{if(!this.isVisible||this.isPaused){this.animationId=requestAnimationFrame(this.animate);return}const t=e-this.lastFrameTime,n=1e3/this.targetFrameRate;if(t>=n){const s=this.simulate();this.visualizer.draw(s),this.lastFrameTime=e}this.animationId=requestAnimationFrame(this.animate)};stop=()=>{this.animationId&&(cancelAnimationFrame(this.animationId),this.animationId=void 0)};pause=()=>{this.isPaused=!0};resume=()=>{this.isPaused=!1,this.animationId||this.animate()};handleVisibilityChange=()=>{this.isVisible=!document.hidden,this.isVisible&&!this.animationId&&this.animate()};restrictScroll=()=>{this.scrollY<0&&(this.scrollY=0),this.scrollY>3400&&(this.scrollY=3400)};handleScroll=e=>{this.scrollY+=e,this.restrictScroll(),this.scrollEndCount=6};handleTouchScroll=e=>{this.touchScrollPrevY&&(this.scrollY-=2*(e-this.touchScrollPrevY)),this.touchScrollPrevY=e,this.restrictScroll(),this.scrollEndCount=6};simulate=()=>{if(this.scrollEndCount-=1,this.scrollEndCount===0){this.touchScrollPrevY=void 0;const n=`${window.location.pathname}?depth=${this.scrollY}`;window.history.replaceState(null,"Fractal-Visualizer depth: + scrollY",n)}const e=this.simulators.map(n=>n.simulate()),t=this.scrollY/300;for(const n of e)for(const s of n.points)s.y-=t;return e}}class E{nullableContext=null;setContext=e=>{this.nullableContext=e;const t=e.canvas.width,n=e.canvas.height;e.fillStyle="rgb(0, 0, 0)",e.fillRect(0,0,t,n)};draw=e=>{const t=this.nullableContext;if(t!==null){const n=t.canvas.width,s=t.canvas.height;t.fillStyle="rgba(0, 0, 0, 0.05)",t.fillRect(0,0,n,s);for(const r of e)E.shouldDrawChart(r.points)&&E.drawChart(t,r,n,s)}};static drawLine=(e,t,n,s,r)=>{e.lineWidth=s,e.strokeStyle=r,e.beginPath(),e.moveTo(t.x,t.y),e.lineTo(n.x,n.y),e.closePath(),e.stroke()};static drawTriangle=(e,t,n,s,r)=>{const o=n.x-t.x,i=n.y-t.y,a=Math.sqrt(o*o+i*i),u=o/a,l=i/a;e.fillStyle=r,e.beginPath(),e.moveTo(n.x,n.y),e.lineTo(t.x+l*s,t.y-u*s),e.lineTo(t.x-l*s,t.y+u*s),e.lineTo(n.x,n.y),e.closePath(),e.fill()};static drawCircles=(e,t,n,s,r)=>{const o=Math.log(s||11),i=n.x-t.x,a=n.y-t.y,u=Math.sqrt(i*i+a*a),l=o*u,d=2*Math.PI;e.fillStyle=r,e.beginPath(),e.arc(t.x+i*.3,t.y+a*.3,l*.3,0,d),e.fill(),e.beginPath(),e.arc(t.x+i*.6,t.y+a*.6,l*.15,0,d),e.fill()};static drawCurve=(e,t,n,s,r)=>{const o=1.5*(s||1),i=n.x-t.x,a=n.y-t.y,u=Math.sqrt(i*i+a*a),l=i/u,d=a/u,y=t.x+(n.x-t.x)/2,f=t.y+(n.y-t.y)/2,h=d*o,w=l*o;e.fillStyle=r,e.beginPath(),e.moveTo(t.x,t.y),e.bezierCurveTo(y+1.5*h,f-1.5*w,y+1.5*h,f-1.5*w,n.x,n.y),e.bezierCurveTo(y+2*h,f-2*w,y+2*h,f-2*w,t.x,t.y),e.closePath(),e.fill()};static shouldDrawChart=e=>{const t=e.map(r=>r.y),n=Math.min(...t);return Math.max(...t)>-1&&n<1};static drawChart=(e,t,n,s)=>{const r=t.points.map(a=>({x:a.x*n,y:a.y*s})),{style:o}=t,i=(()=>{switch(o.type){case A.LINE:return E.drawLine;case A.TRIANGLE:return E.drawTriangle;case A.CIRCLES:return E.drawCircles;case A.CURVE:return E.drawCurve;default:throw new Error("Invalid style type!")}})();for(let a=0;a<t.orders.length;a+=1){const u=t.orders[a],{link:l}=u,d=t.colors[a],y=r[l[0]],f=r[l[1]];i(e,y,f,o.thickness,d)}}}class Y{visualizer;simulator;static adjustCanvas=e=>{const t=window.devicePixelRatio;e.width=window.innerWidth*t*2,e.height=window.innerHeight*t*2};constructor(e,t){this.visualizer=e,this.simulator=t;const n=document.getElementById("canvas");if(n instanceof HTMLCanvasElement){if("ontouchstart"in window){const r=(i=>{i.preventDefault()}),o=(i=>{i.preventDefault(),this.simulator.handleTouchScroll(i.touches[0].pageY)});n.addEventListener("touchstart",r,{passive:!1}),n.addEventListener("touchend",r,{passive:!1}),n.addEventListener("touchcancel",r,{passive:!1}),n.addEventListener("touchmove",o,{passive:!1})}else n.onwheel=r=>{this.simulator.handleScroll(r.deltaY)};window.onresize=()=>{Y.adjustCanvas(n)};const s=n.getContext("2d");s instanceof CanvasRenderingContext2D&&(Y.adjustCanvas(n),this.visualizer.setContext(s),this.simulator.start(50))}}}class ae{constructor(){const e=new E,t=new ie(e);new Y(e,t)}}new ae;
